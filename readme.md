## 设计

**目标**
每个程序可以单独运行，使用 docker 控制内存和 cpu 使用情况

可以多个程序同时使用

**方法**

使用 redis 作为队列
生产者向队列中提交任务，消费者获取任务

每个程序都即使生产者也是消费者，生产者协程通过 redis 加锁获得生产权限，消费者协程获取 redis 队列内的任务。

任务 id 通过任务目录 hash 获得

#### 配置

1. 目标对象存储的配置
2. 源对象存储的配置
3. 任务目录
4. 消息队列的配置
5. 全局锁配置
6. 消费者并发数

cmd args：

1. 配置文件路径（可以通过 docker -v 挂载只读文件的方式将配置文件放入）

#### 生产者

只负责根据任务目录获取所有的任务，并且丢入消息队列

生产者需要判断：

1. 源地址是否存在
2. 目标地址是否存在

#### 消费者

只负责从消息队列中取出任务

#### 消息队列

实现两个接口：

1. Put
2. Get(offset)
3. Ack(offset)

- 本地消息队列由 golang channle 实现
- 全局消息队列由 redis 实现

生产者 Put 的过程考虑：

- 如果是一次性写入所有文件地址的，则需要保证写入过程是原子的；
- 如果文件地址不是一次性写入的，则需要解决两个问题：
  1. 失败后如何续写
  2. 如何确保任务不是被消费掉了，而是没有写入

数据被消费掉只能是 offset 偏移，而不是任务记录删除。
